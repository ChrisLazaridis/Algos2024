# Δοθέντος ενός πίνακα ακεραίων, nums, και βρισκόμενος αρχικά στο πρώτο index, μπορείς να πηδήξεις κάθε φορά κατά μέγιστο
# όσο είναι η τιμή του πίνακα στο index στο οποίο βρίσκεσαι. Δηλαδή αν είμαι στο index 1 και nums[1]= 4 μπορώ κατά μέγιστο
# να πάω στο index 5. Να επιστραφεί True αν μπορώ να φτάσω στο τέλος του array, διαφορετικά False
# Άπληστη λογική, για κάθε κόμβο στον οποίο μπορώ να φτάσω,
# βλέπω το μέγιστο κόμβο στον οποίο μπορώ να βρεθώ και ανανεώνω το τωρινό μέγιστο, αν είναι μεγαλύτερο
# Άπληστη διότι παίρνω πάντα τα μέγιστα
# Αν φτάσω στο σημείο να μπορώ να επισκεφτώ το τελευταίο κόμβο πριν τελειώσω την επανάληψη επιστρέφω True
# Αλλιώς επιστρέφω False
# Επίσης επιστρέφω False αν το i > max_reach διότι αν συμβαίνει αυτό δεν μπορώ να φτάσω με κανένα τρόπο στο κόμβο
# τον οποίο θα ήθελα να ελέγξω, άρα δεν μπορώ με τίποτα να φτάσω στο τελικό
def canJump(nums: list[int]) -> int:
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
        if max_reach >= len(nums) - 1:
            return True
    return False

# Χρονική πολυπλοκότητα: O(n) κατά χειρότερη περίπτωση
# Χωρική πολυπλοκότητα: O(c)
# ΥΓ: I'M TOO GOOD
