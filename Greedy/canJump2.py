# Δοθέντος ενός πίνακα ακεραίων, nums, και βρισκόμενος αρχικά στο πρώτο index, μπορείς να πηδήξεις κάθε φορά κατά μέγιστο
# όσο είναι η τιμή του πίνακα στο index στο οποίο βρίσκεσαι. Δηλαδή αν είμαι στο index 1 και nums[1]= 4 μπορώ κατά μέγιστο
# να πάω στο index 5. Να επιστραφεί ο μικρότερος αριθμός πηδημάτων με τα οποία μπορώ να φτάσω στο τέλος
# Σημείωση: μπορώ πάντα να φτάσω στο τέλος
# Πάλι άπληστη λογική
# Αν είμαι στο μέγιστο κόμβο που μπορώ να φτάσω, ανανεώνω το max_reach με το νέο μέγιστο κόμβο και προσθέτω ενα βήμα
# Όταν φτάσω στο τέλος επιστρέφω τον αριθμό των βημάτων
def NoJumps(nums: list[int]) -> int:
    if len(nums) <= 1:
        return 0

    max_reach = 0
    edge = 0
    steps = 0

    for i in range(len(nums)):
        max_reach = max(max_reach, i + nums[i])
        if i == edge:
            steps += 1
            edge = max_reach
            if edge >= len(nums) - 1:
                return steps

# Χρονική πολυπλοκότητα: O(n) κατά χειρότερη περίπτωση
# Χωρική πολυπλοκότητα: O(c)
